<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8">
  <title>Asynchronous Apex</title>
  <link rel="stylesheet" href="../test.css">
</head>

<body>
  <header>
    <h1>Asynchronous Apex Examples</h1>
  </header>

  <section>

    <!-- EXAMPLE 1 -->
    <div class="example">
      <p><span class="counter"></span> - Can I use Apex asynchronously? </p>
      <button class="showSolution">Show Solution</button>
      <pre>
        Off course, Apex offers multiple ways for running your Apex code asynchronously.

        • Future Methods
            - When you have a long-running method and need to prevent delaying an Apex transaction
            - When you make callouts to external Web services
            - To segregate DML operations and bypass the mixed save DML error
        
        • Queueable Apex
            - To start a long-running operation and get an ID for it
            - To pass complex types to a job
            - To chain jobs
        
        • Batch Apex
            - For long-running jobs with large data volumes that need to be performed in batches, such as database maintenance jobs
            - For jobs that need larger query results than regular transactions allow
        
        • Scheduled Apex
            - To schedule an Apex classes to run on a specific schedule 
      </pre>
    </div>

    <!-- EXAMPLE 2 -->
    <div class="example">
      <p><span class="counter"></span> - Future Methods </p>
      <button class="showSolution">Show Solution</button>
      <pre>
        <em> // Future Apex (also known as @future methods) is used for performing long-running operations asynchronously, often used for tasks like sending emails, making external web service calls, or other operations that should not block the main transaction. </em>
        public class EmailSender {

          @future
          public static void sendEmail(String toAddress, String subject, String body) {
              <em> // Perform email sending logic here </em>
              Messaging.SingleEmailMessage mail = new Messaging.SingleEmailMessage();
              mail.setToAddresses(new String[]{toAddress});
              mail.setSubject(subject);
              mail.setPlainTextBody(body);
              Messaging.sendEmail(new Messaging.SingleEmailMessage{mail});
          }
        }
        <em>
          // We have a sendEmail method annotated with @future. This indicates that the method will be executed asynchronously in a separate context.
          // Inside the sendEmail method, we perform the logic to send an email using Salesforce's Messaging API.
        </em>
        // Now, you can call this sendEmail method from another context, such as a trigger, to send emails asynchronously.
        trigger MyObjectTrigger on MyObject__c (after insert) {
          for (MyObject__c obj : Trigger.new) {
            String toAddress = 'recipient@example.com';
            String subject = 'Hello from Salesforce Future Apex';
            String body = 'This is an asynchronous email from Salesforce.';
            
            <em> // Call the future method to send the email asynchronously </em>
            EmailSender.sendEmail(toAddress, subject, body);
          }
        }
        <em>
          // We define a trigger on the MyObject__c object that runs after insert.
          // Inside the trigger, we loop through the records being inserted and call the sendEmail method from the EmailSender class.
          // The email sending logic is executed asynchronously in a separate context, allowing the main transaction to continue without waiting for the email to be sent.
          // This is just one example of how you can use @future methods in Salesforce to perform operations asynchronously and avoid blocking the main transaction.
        </em>
      </pre>
    </div>

    <!-- EXAMPLE 3 -->
    <div class="example">
      <p><span class="counter"></span> - Queueable Apex </p>
      <button class="showSolution">Show Solution</button>
      <pre>
        <em> // Salesforce Queueable Apex allows you to perform asynchronous processing of tasks in a more flexible manner compared to @future methods. </em>
        public class UpdateRecordsQueueable implements Queueable {
             private List<Id> recordIds;
             public UpdateRecordsQueueable(List<Id> ids) {
                this.recordIds = ids;
             }
    
             public void execute(QueueableContext context) {
                // Perform the record updates here
                List<MyObject__c> recordsToUpdate = [SELECT Id, Name FROM MyObject__c WHERE Id IN :recordIds];
                  
                for (MyObject__c record : recordsToUpdate) {
                   // Perform updates, for example:
                   record.Name = 'Updated Name';
                }
        
                // Update the records
                update recordsToUpdate;
             }
         }
         <em>
           // We've created a class called UpdateRecordsQueueable that implements the Queueable interface.
           // The class takes a list of record IDs as a parameter through its constructor.
           // Inside the execute method, we query and update records based on the provided IDs. This is where you can perform your specific logic.
         </em>
         // Now, you can enqueue this Queueable job from anywhere in your Salesforce code, such as a trigger or another Apex class.
         trigger MyObjectTrigger on MyObject__c (after update) {
            List<Id> recordIds = new List<Id>();
            for (MyObject__c obj : Trigger.new) {
               if (obj.SomeCriteria__c) {
                  recordIds.add(obj.Id);
               }
            }
    
            if (!recordIds.isEmpty()) {
               // Enqueue the Queueable job
               System.enqueueJob(new UpdateRecordsQueueable(recordIds));
            }
          }
          <em>
            // We define a trigger on the MyObject__c object that runs after an update.
            // Inside the trigger, we collect the IDs of records that meet certain criteria.
            // If there are records to update, we enqueue the UpdateRecordsQueueable job with the list of record IDs.
            // The execute method of the UpdateRecordsQueueable class will be executed asynchronously, allowing you to update records without blocking the main transaction.
            // This is a powerful way to handle long-running or resource-intensive tasks in Salesforce while maintaining good performance and flexibility.
          </em>
      </pre>
    </div>

    <!-- EXAMPLE 4 -->
    <div class="example">
      <p><span class="counter"></span> - Batchable Apex </p>
      <button class="showSolution">Show Solution</button>
      <pre>
         <em>
           // Batch Apex allows you to process large sets of data in smaller, manageable chunks.
           // Batch Apex is an excellent way to handle large-scale data processing in Salesforce while respecting platform limits and maintaining good performance.
         </em> 
         <em> // A Batchable class to update a custom field on all Account records. </em>
         public class UpdateAccountBatch implements Database.Batchable<sObject> {
            public Database.QueryLocator start(Database.BatchableContext context) {
               // Query all Account records that need to be updated
               return Database.getQueryLocator('SELECT Id, CustomField__c FROM Account WHERE SomeCriteria__c = true');
            }
    
            public void execute(Database.BatchableContext context, List&lt;Account&gt; listAcc) {
               // Process each batch of Account records
               for (Account acc : listAcc) {
                  // Update the custom field value, e.g., increment it
                  acc.CustomField__c += 1;
               }
        
               // Update the records in this batch
               update scope;
             }
    
             public void finish(Database.BatchableContext context) {
                // Optionally, perform any post-processing tasks here
             }
          }
          <em>
            // We've created a class called UpdateAccountBatch that implements Database.Batchable&lt;sObject&gt;.
            // The start method returns a Database.QueryLocator that defines the set of records to be processed. In this case, it selects Account records meeting specific criteria.
            // The execute method processes each batch of records. It updates the CustomField__c on each Account record and then performs an update operation.
            // The finish method is called after all batches have been processed, allowing for any necessary post-processing.
          </em>
          <em> // To execute the batch job programmatically </em>
          UpdateAccountBatch myBatch = new UpdateAccountBatch();
          Database.executeBatch(myBatch, 200); <em> // The second parameter is the batch size </em>
          <em>
            // We create an instance of the UpdateAccountBatch class.
            // We use Database.executeBatch to start the batch job. The second parameter, 200, is the batch size, indicating that each batch will process up to 200 records.
            // This initiates the batch job, and Salesforce will automatically break down the processing into manageable chunks, updating the custom field on all relevant Account records.
          </em>

      </pre>
    </div>

  </section>

  <script src="examples.js"></script>

</body>

</html>
